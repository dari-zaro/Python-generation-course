ЦИКЛ WHILE

В языке Пайтон есть несколько видов циклов, один из них while ( пока/в то время как)

Это цикл с предусловием.
Цикл содержит ключевое слово while, потом предусловие, и действия, которые будут выполняться.  Вся конструкция в целом называется: итерация цикла.

Цикл будет повторяться пока вводные данные соответствуют условию.

end – указывает что делать после вывода строки.
Пример:
print(10, end=' что-то сюда пишешь ')
В кавычках указываешь, что делать. Можно поставить просто пробел, чтобы, например, при выводе массива цифр значения шли через пробел.

Как в целом выглядит цикл:

while <логическое условие>:
      действие 1
      действие 2 (что-то, что изменит вводные данные, например a -= 1. Тогда входящая переменная изменится на 1)


ОПЕРАТОРЫ break, continue

Эти операторы полезны при работе с циклами.

split() разделяет строку по разделителю. Пример:
a, b = input().split()
Или 
print(text.split(',')) – яблоко, 'банан', 'апельсин'
Для split можно указать максимум разделений, это второе число в скобках, пример:
str = ' один два три четыре'
print(text.split(' '), 2))
'один', 'два', 'три'
Заметь, что четыре не вывелось, так как было указано, что можно использовать всего два разделения. Для четверки потребовалось бы третье.

break- оператор завершения цикла. Точнее, это досрочное завершение цикла.
Например, при каком-то определенном условии нужно завершить цикл, и это можно сделать вставив оператор break

continue – завершить текущую операцию цикла и перейти к следующей.
Короче, он досрочно прерывает цикл, но при этом возвращает нас обратно к условию и цикл продолжается.

Иногда нужно сделать цикл бесконечным или избежать условия, можно схитрить таким образом: ввести переменную, которая будет запускать цикл, а внутри цикла задать другую переменную, уже ту, с которой нужно будет работать дальше. Таким образом, цикл будет запускать по введенной для запуска переменной и не будет зависеть от введённых в нем данных, пока не завершишь операцию сам, или пока цикл не наткнется на break.
ЦИКЛ for

for – позволяет делать повторяющееся действие с последовательностью элементов.

Пример:
for i in 2, 3, 5: (здесь i – переменная, которая модет перенимать значение какого-то элемента. Т.е. i примет значение 2, потом, 3, потом 5)
 print(i * i)
4
9
25

for часто используется вместе с функцией range – взять значения от 0, до какого-то указанного значения, не включая это значение. Пример:
for I in range(10):
print(I*I)
0
1
2
9
16
...
81 (до девяти, дальше десять, а его мы не берем)

Для функции range можно задать шаг применения значения, а так де от какого до какого числа брать значения. 
range(2, 8) – взять значения от 2 до 8, при этом 2 входит, а 8 не войдет. Шаг будет равен 1. 
Чтобы задать шаг нужно указать третье значение.
range(5, 25, 5) 
5, 10, 15, 20 - Мы берем значения от 5 до 25, не включая 25, с шагом 5.
Если мы хотим включить правую границу в интервал, то нужно дописать к ней +1, пример:
range(5, 25 + 1, 5). Теперь 25 будет включено в цикл.

Можно записать и так:
range(start = 0, to, step = 1)
Хрен знает че это. Забей.

При использовании range print будет выводить по одному значению в строке, если хочешь, чтобы все значения выводились в строку, используй 
print('а, b, c', end = '')

Можно использовать и отступ(красную строку) с \t, пример:
print('раз\tдва\tтри')
раз   два    три

\n – работает так же как и \t, но здесь произойдет перенос на новую строку.

\n и \t– управляющие символы. Они управляют выводом, модифицируют его.

Эта хня работает только в цикле for, лол. 





СТРОКИ И СИМВОЛЫ

записанное в строке можно рассматривать как отдельные символы, об этом больше пойдет речь.

Пример:

genome = 'ATGG' – допустим, есть такая строка. Символы в строке нумеруются, и нумерация начинается с нуля. Т.е., индекс 'А' это ноль, а не единица.

С помощью введенной индексации можно обратиться к определенному символу в строке. Индекс записывается в квадратных скобках, пример:

genome[0] A
genome[1] T
genome[2] G

Можно использовать отрицательную индексацию, и символы будут считаться с конца.

Индексацию можно производить с помощью введенной переменной, пример:

a=1
print(genome[a])
Получим T

Строки неизменяемы, потому нельзя просто так взять и поменять один символ в строке. Если попытаться присвоить индексу в строке значение будет ошибка.
Чтобы что-то изменить нужно создать копию строки и в этой копии поменять то что тебе надо, но об этом позже.

Это можно использовать в циклах. Пример:
genome = ' ATGG'
for i in range(4):
print(genome[i])
A
T
G
G
Что произошло: мы в цикле перебрали цифры от 0 до 3 и таким образом вывели все значения из строки по отдельности.

Так же цикл for можно использовать для перечисления всех символов в строке. Пример:
genome = ' ATTG'
for c in genome:
print(c)
A
T
T
G
Какой смысл кода: мы говорим– пусть переменная с принимает по очередно все значения которые есть в строке genome по порядку. Это способ без использования индексации.

Строки имеют методы. Методы: что-то типо анализа строки на соответствие определенному условию. 

К методам относится count – эта операция покажет сколько раз указанный символ встречается в строке. Пример оформления:

a = input() – скажем, вводим сюда длинную строку из букв, допустим CHDCFVNCCFC
print(a.count('C')) – вывести сколько раз в переменной a встречается строка c.Count в переводе – считать.
4

НЕКОТОРЫЕ МЕТОДЫ У СТРОК:
Пример: 
s = 'aTGcc'
p = 'cc'
Методы:
-	s.upper() >> 'ATGCC' (этот метод заменяет все строчные буквы на заглавные. Upper переводится как 'верхний')
-	s.lower()  >> 'atgcc' (все буквы в строке строчные. Lower– ниже.)
-	s.count(p) >> 1 (сколько раз p встречается в строке s. Count - считать.)
-	s.find(p) >> 3 (найти первое вхождение p в строке s. Короче, найти индекс самой первой p. Find– искать.)
-	s.find('A') >> -1 (Найти самое первое 'А' в строке s. Эта строка не входит в s, потому такой ответ.  Рекомендуется осуществлять проверку вхождения в строку: if 'TG' in s: ...
-	s.replace('c','C') >> 'aTGCC' (Позволяет заменить все вхождения 'с' на 'С'. Replace– заменять.)
Можно использовать сразу несколько вызовов методов в одной строке.
Пример:
s = 'agTtcAGtc'
s.upper().count('gt'. upper()) – Что тут происходит: сначала делаем всю строку s большими буквами. В этой строке мы ищем вхождение 'gt', при этом мы ищем ее с методом upper, т.е. мы ищем не просто 'gt', а 'GT'.
>> 2

Напомню: 
len(s) -длина определенной строки.

У строк можно брать диапазоны значений. Для этого существует специальный механизм – slicing (нарезка).

Пример:
dna= 'ATTCGGAGCT'
dna[1] >> 'T'
dna[1:4] >> 'TTC' – индексом указываем диапазон значений. При этом последнее значение не включается в диапазон.
dna[:4] >> 'ATTC' – если не указать первого значения то будет считаться, что оно равно нулю. Получается, у нас диапазон с самого начала до индекса 4. Аналогично можно не указывать правую границу, тогда будут браться значения от указанного левого символа до конца. Это будет:
dna[4:] >> 'GGAGCT'
dna[-4:] >>'AGCT' – индекс считается с конца.
dna[1:-1] >> 'TTCGGAGC' 
dna[1:-1:2] >> ' TCGG' -третье значение, это шаг с которым мы берем символы. Закончится цикл тогда, когда значение будет равно правой границе или будет больше.
dna[::-1] >> 'TCGAGGCTTA' -можно использовать отрицательный шаг. Т.е. символы будут читаться справа налево. Конкретно эта конструкция обозначает перевернутую строку. Тут символы будут подряд браться справа налево.


СПИСКИ

Списки используются чтобы хранить наборы значений, и манипулировать этими значениями.
Элементами списка могут быть про звольные значения, строки, числа, произвольные объекты, даже другие списки. В одном списке можно компилировать объекты разных типов. 

Элементы списка указываются в квадратных скобках. Пример:
Студенты = ['Иван', 'Маша', 'Даша']
Этот список можно использовать чтобы выполнить цикл с каждым элементом списка. Как будет выглядеть цикл:
for студент in студенты:
print('Привет,' + student + '!')
Привет, Иван!
Привет, Маша!
Привет, Даша!

К каждому элементу списка можно получить доступ. Это делается с помощью индекса. Тут все так же как со строками. Нумерация начинается с нуля. Длина списка проверяется так же через len. Как и со строками можно использовать отрицательную индексацию, и начинается она с -1.

Как и в строках можно взять интервалы, в общем, все что было справедливо для строк справедливо и для списков. Методы сюда не относятся, они только для строк, у списков есть свои методы и операции.

Какие можно проводить операции со списками:
Сложение – к элементам перстго списка в конце припишутся элементы второго списка. Изначальные списки не меняются в результате операции. Появится новый список.
Умножение на целое число – список просто будет повторяться, вот и все.

В строках нельзя было менять элементы, а в списках можно.
Допустим, есть список студентов. Используя индекс можно поменять значение одного из элементов списка.

Студенты = ['Иван', 'Маша', 'Даша']
Студенты[1] = 'Олег'
print(Студенты)
>>  ['Иван', 'Олег', 'Даша']
Помимо изменения элементов в списке мы можем добавлять в него новые элементы, или удалять. 

Добавление в список:
1)	Студенты = ['Иван', 'Маша', 'Даша']
Студенты.append('Ольга')
>> Студенты = ['Иван', 'Маша', Даша, 'Ольга']
Этот метод добавляет в конец списка указанный элемент.
2)	Студенты += ['Ольга']
Так же прибавляет указанный элемент в конец списка. Обязательно указать элемент в квадратных скобках, так как этот элемент должен быть включен в список. Списки могут иметь повторяющиеся элементы. К списку этими же способами можно добавлять списки, состоящие из нескольких элементов.

Пустой список:
Студенты[] -в скобках тупо пусто.

Часто в программах используются пустые списки. Создается пустой список и, проходя определенный цикл, наполняется элементами.

3)	Можно вставлять элементы в середину списка.
Студенты = ['Иван', 'Маша', 'Даша']
Студенты. insert(1,'Ольга')
Первый параметр– позиция в которую вставляем элемент.
Второй параметр – сам элемент.
>> Студенты = ['Иван','Ольга', 'Маша', 'Даша']

Еботь.

Короче, строка– это список из букв.  Типо ['Ольга'] – это один элемент списка, а 'Ольга'– это уже 5 элементов. 

Удаление из списка:
1)	Студенты = ['Иван', 'Маша', 'Даша']
Студенты. remove('Даша')
>> Студенты = ['Иван', 'Маша']
Этот метод удаляет из списка указанный элемент.

2)	del Студенты [0]
>> ['Маша']
del так же удаляет элемент. 

При этом метод remove если у нас Даш в списке было несколько удалил бы только первую Дашу, остальных бы не тронул.
Если попробовать удалить из списка несуществующий элемент, будет ошибка.

Как проверить наличие элемента в списке?
1)	Используй формулу:
if 'Даша' in Студенты:
print('Даша здесь')
if 'Аня' not in Студенты:
print('Аня отсутствует')

2)	использовать функцию ind.
ind = Студенты. index('Иван')
>> 1
Если вписать элемент, которого в списке нет, будет ошибка.

Сортировка списка.

Допустим, я хочу упорядочить свой список по возрастанию.
Можно использовать функцию: sorted.

Записывается как:
ordered_Студенты = sorted(Студенты)
ordered – заказать.

Есть другой вариант: sort

Этот метод изменяет сам список. Как записывается:
Студенты. sort()
Здесь можно использовать min(), max(). min() выведет минимальное значение в списке, max() выведет максимальное.

Чтобы все это можно было применить нужно чтобы все элементы спискабыли сравнимы. В плане, они должны все быть одного типа. Если в списке цифры, то цифрами должны быть все компоненты, если всё строки, то цифр быть не должно.

Можно получить элементы списка в обратном порядке. 
Для этого нужен метод reverse()
Как записать:
Студенты. reverse()

Метод 
reversed(Студенты) 
делает все то же самое, что и reverse, но тот изменяет сам список, а reversed не изменяет начальный список, и делает копию списка, но в обратном порядке.

Все то же самое можно сделать через индексы:
Студенты[::-1]
При этом изначальный список тоже никак не изменится.


Присвоение списков

Тот факт, что списки можно на ходу изменять, вводит в работу со списками некоторые изменения. Это касается присвоения списков.
Допустим а = значения в списке, а б=а. Если я через переменную а и индекс поменяю значение одного из элементов, в б список тоже изменится. То же самое будет, если поменять значение в списке через индекс с переменной б. Я могу влиять на список как чере переменную а, так и через б.

Когда переменной присваивается новое значение связь разрывается, и больше а и б не связаны.


Генерация списков

Списки могут содержать огромное количество элементов, и пополнять списки вручную проблематично. Для генерации списков есть специальные функции.

1)	a[0] * 5
>>00000

2)	a= [0 for i in range(5)]
Мы используем переменную, в этом случае i. Указываем значение которое должна принимать переменная. В результате цикла переменная пройдет все указанные значения.
В курсе этот момент показали оч непонятно, я нихрена не поняла че делает эта хрень.
Ааа, хосподя. Я понял.
3)	a=[i*i for i in range(5)]
Здесь каждое значение будет ввозведено в квадрат.
4)	a = [int(i) for i in input(). split()]
Это преобразование списка цифр в ннатуральные числа. На input вводится список из цифр, split разделяет значения пробелом, а int преобразует каждое значение в натуральное число.

Метод split

С помощью этого метода строку можно разделить на список строк подстрок по определенному разделителю.
Split сканирует всю строку и разделяет ее в случае нахождения разделителя. Пробел– разделитель по умолчанию для этой функции. Если разделитель не указать, то разделение будет именно по пробелу.


ГЕНЕРАЦИЯ ДВУМЕРНЫХ СПИСКОВ

Как хранить электронную таблицу или матрицу. 

Простейший пример двумерного списка:
a=[[1,2,3], [4,5,6,], [7,8,9]]
В списке три элемента, и каждый элемент так же является списком.
Такой список можно представить таблицей, если выводить поочередно индексы каждого из элементов.

В таких случаях, когда внутри списка есть список, можно брать двойную индексацию, пример:
a[1] [1]
>>5
Что мы сказали компьютеру: возьми в элементе с индексом 1 элемент с индексом 1. А это 5.

Пример генерации квадратной матрицы:
a = [[0]*n]*n
Сгенерируется таблица:
0 0 0
0 0 0
0 0 0 
Теперь если мы захотим изменить элемент мы можем попытаться сделать это так:
a[0] [0]=5
Но тогда у нас изменится все и таблица станет выглядеть так:
5 5 5 
5 5 5
5 5 5
Это потому что у нас таблица состоит полностью из ссылок на а. Для правильной генерации таблицы нужно использовать формулу:
a=[[0]*n for I in range(n)]
Такая конструкция создаст список из n списков из n нулей, где каждый из элементов списка будет независимым. Вот здесь можно изменить один из элементов и это никак не отразится на таблице.

Есть и такой вариант:
a=[[0 for j in range(n)] for i in range(n)]
Что тут происходит: внутренняя конструкция создает список из n нулей, и этот генератор мы запускаем n раз. В итоге тоже получаем список из n нулей.


ПОИСК МИНИМУМА В СПИСКЕ

Пример:
Есть список: 
a=[5 8 4 3 5 7 ]
Допустим, надо найти минимум– 3
Для этого мы заводим переменную и указываем туда значение первого элемента в списке:
m=a[0]
Дальше нужно перебрать все элементы списка и сравнить с m. Если встретившееся значение меньше значения m, нужно обновить m на это значение. Тогда, пройдя так по всему списку, m в итоге достигнет минимума.
Далее как будет выглядеть программа – это я напишу в Jupyter. Смотри там.

map() перебирает элементы итерируемого массива (или коллекции) и возвращает новый массив (или итерируемый объект), который является результатом применения функции преобразования к каждому элементу исходного итерабельного массива.

(mapping). map() полезен, когда вам нужно применить функцию преобразования к каждому элементу в коллекции или в массиве и преобразовать их в новый массив.

square() — это функция преобразования, которая преобразует число в его квадратное значение.
Пример с map:
>>> str_nums = ["4", "8", "6", "5", "3", "2", "8", "9", "2", "5"]
>>> int_nums = map(int, str_nums)

В Python есть ключевое слово list (). Это функция, которая либо создает пустой список, либо приводит к списку итерируемый объект. Чтобы создать пустой объект списка с помощью функции, напишите: 1 mylst = list ()

Функция abs () — это встроенная функция, возвращающая абсолютное значение числа. Она принимает целые, с плавающей точкой и комплексные числа на вход. Если передать в abs () целое число или число с плавающей точкой, то функция вернет не-отрицательное значение n и сохранит тип. Для целого числа — целое число. Для числа с плавающей точкой — число с плавающей точкой.>>> abs (20) 20>>> abs (20.0) 20.0>>> abs (-20.0) 20.0.
